// Code generated by mockery v1.1.1. DO NOT EDIT.

package auth

import (
	gocloak "github.com/Nerzal/gocloak/v5"
	jwt "github.com/dgrijalva/jwt-go"

	mock "github.com/stretchr/testify/mock"

	resty "github.com/go-resty/resty/v2"
)

// MockGoCloak is an autogenerated mock type for the GoCloak type
type MockGoCloak struct {
	mock.Mock
}

// AddClientRoleComposite provides a mock function with given fields: token, realm, roleID, roles
func (_m *MockGoCloak) AddClientRoleComposite(token string, realm string, roleID string, roles []gocloak.Role) error {
	ret := _m.Called(token, realm, roleID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, []gocloak.Role) error); ok {
		r0 = rf(token, realm, roleID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddClientRoleToGroup provides a mock function with given fields: token, realm, clientID, groupID, roles
func (_m *MockGoCloak) AddClientRoleToGroup(token string, realm string, clientID string, groupID string, roles []gocloak.Role) error {
	ret := _m.Called(token, realm, clientID, groupID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(token, realm, clientID, groupID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddClientRoleToUser provides a mock function with given fields: token, realm, clientID, userID, roles
func (_m *MockGoCloak) AddClientRoleToUser(token string, realm string, clientID string, userID string, roles []gocloak.Role) error {
	ret := _m.Called(token, realm, clientID, userID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(token, realm, clientID, userID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddDefaultGroup provides a mock function with given fields: accessToken, realm, groupID
func (_m *MockGoCloak) AddDefaultGroup(accessToken string, realm string, groupID string) error {
	ret := _m.Called(accessToken, realm, groupID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(accessToken, realm, groupID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddDefaultScopeToClient provides a mock function with given fields: token, realm, clientID, scopeID
func (_m *MockGoCloak) AddDefaultScopeToClient(token string, realm string, clientID string, scopeID string) error {
	ret := _m.Called(token, realm, clientID, scopeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(token, realm, clientID, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddOptionalScopeToClient provides a mock function with given fields: token, realm, clientID, scopeID
func (_m *MockGoCloak) AddOptionalScopeToClient(token string, realm string, clientID string, scopeID string) error {
	ret := _m.Called(token, realm, clientID, scopeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(token, realm, clientID, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddRealmRoleComposite provides a mock function with given fields: token, realm, roleName, roles
func (_m *MockGoCloak) AddRealmRoleComposite(token string, realm string, roleName string, roles []gocloak.Role) error {
	ret := _m.Called(token, realm, roleName, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, []gocloak.Role) error); ok {
		r0 = rf(token, realm, roleName, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddRealmRoleToGroup provides a mock function with given fields: token, realm, groupID, roles
func (_m *MockGoCloak) AddRealmRoleToGroup(token string, realm string, groupID string, roles []gocloak.Role) error {
	ret := _m.Called(token, realm, groupID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, []gocloak.Role) error); ok {
		r0 = rf(token, realm, groupID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddRealmRoleToUser provides a mock function with given fields: token, realm, userID, roles
func (_m *MockGoCloak) AddRealmRoleToUser(token string, realm string, userID string, roles []gocloak.Role) error {
	ret := _m.Called(token, realm, userID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, []gocloak.Role) error); ok {
		r0 = rf(token, realm, userID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddUserToGroup provides a mock function with given fields: token, realm, userID, groupID
func (_m *MockGoCloak) AddUserToGroup(token string, realm string, userID string, groupID string) error {
	ret := _m.Called(token, realm, userID, groupID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(token, realm, userID, groupID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClearKeysCache provides a mock function with given fields: token, realm
func (_m *MockGoCloak) ClearKeysCache(token string, realm string) error {
	ret := _m.Called(token, realm)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(token, realm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClearRealmCache provides a mock function with given fields: token, realm
func (_m *MockGoCloak) ClearRealmCache(token string, realm string) error {
	ret := _m.Called(token, realm)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(token, realm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ClearUserCache provides a mock function with given fields: token, realm
func (_m *MockGoCloak) ClearUserCache(token string, realm string) error {
	ret := _m.Called(token, realm)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(token, realm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateChildGroup provides a mock function with given fields: token, realm, groupID, group
func (_m *MockGoCloak) CreateChildGroup(token string, realm string, groupID string, group gocloak.Group) (string, error) {
	ret := _m.Called(token, realm, groupID, group)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.Group) string); ok {
		r0 = rf(token, realm, groupID, group)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, gocloak.Group) error); ok {
		r1 = rf(token, realm, groupID, group)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClient provides a mock function with given fields: accessToken, realm, clientID
func (_m *MockGoCloak) CreateClient(accessToken string, realm string, clientID gocloak.Client) (string, error) {
	ret := _m.Called(accessToken, realm, clientID)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, gocloak.Client) string); ok {
		r0 = rf(accessToken, realm, clientID)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, gocloak.Client) error); ok {
		r1 = rf(accessToken, realm, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientProtocolMapper provides a mock function with given fields: token, realm, clientID, mapper
func (_m *MockGoCloak) CreateClientProtocolMapper(token string, realm string, clientID string, mapper gocloak.ProtocolMapperRepresentation) (string, error) {
	ret := _m.Called(token, realm, clientID, mapper)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.ProtocolMapperRepresentation) string); ok {
		r0 = rf(token, realm, clientID, mapper)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, gocloak.ProtocolMapperRepresentation) error); ok {
		r1 = rf(token, realm, clientID, mapper)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientRole provides a mock function with given fields: accessToken, realm, clientID, role
func (_m *MockGoCloak) CreateClientRole(accessToken string, realm string, clientID string, role gocloak.Role) (string, error) {
	ret := _m.Called(accessToken, realm, clientID, role)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.Role) string); ok {
		r0 = rf(accessToken, realm, clientID, role)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, gocloak.Role) error); ok {
		r1 = rf(accessToken, realm, clientID, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateClientScope provides a mock function with given fields: accessToken, realm, scope
func (_m *MockGoCloak) CreateClientScope(accessToken string, realm string, scope gocloak.ClientScope) (string, error) {
	ret := _m.Called(accessToken, realm, scope)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, gocloak.ClientScope) string); ok {
		r0 = rf(accessToken, realm, scope)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, gocloak.ClientScope) error); ok {
		r1 = rf(accessToken, realm, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateComponent provides a mock function with given fields: accessToken, realm, component
func (_m *MockGoCloak) CreateComponent(accessToken string, realm string, component gocloak.Component) (string, error) {
	ret := _m.Called(accessToken, realm, component)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, gocloak.Component) string); ok {
		r0 = rf(accessToken, realm, component)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, gocloak.Component) error); ok {
		r1 = rf(accessToken, realm, component)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateGroup provides a mock function with given fields: accessToken, realm, group
func (_m *MockGoCloak) CreateGroup(accessToken string, realm string, group gocloak.Group) (string, error) {
	ret := _m.Called(accessToken, realm, group)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, gocloak.Group) string); ok {
		r0 = rf(accessToken, realm, group)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, gocloak.Group) error); ok {
		r1 = rf(accessToken, realm, group)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateIdentityProvider provides a mock function with given fields: token, realm, providerRep
func (_m *MockGoCloak) CreateIdentityProvider(token string, realm string, providerRep gocloak.IdentityProviderRepresentation) (string, error) {
	ret := _m.Called(token, realm, providerRep)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, gocloak.IdentityProviderRepresentation) string); ok {
		r0 = rf(token, realm, providerRep)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, gocloak.IdentityProviderRepresentation) error); ok {
		r1 = rf(token, realm, providerRep)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePermission provides a mock function with given fields: token, realm, clientID, permission
func (_m *MockGoCloak) CreatePermission(token string, realm string, clientID string, permission gocloak.PermissionRepresentation) (*gocloak.PermissionRepresentation, error) {
	ret := _m.Called(token, realm, clientID, permission)

	var r0 *gocloak.PermissionRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.PermissionRepresentation) *gocloak.PermissionRepresentation); ok {
		r0 = rf(token, realm, clientID, permission)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PermissionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, gocloak.PermissionRepresentation) error); ok {
		r1 = rf(token, realm, clientID, permission)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePolicy provides a mock function with given fields: token, realm, clientID, policy
func (_m *MockGoCloak) CreatePolicy(token string, realm string, clientID string, policy gocloak.PolicyRepresentation) (*gocloak.PolicyRepresentation, error) {
	ret := _m.Called(token, realm, clientID, policy)

	var r0 *gocloak.PolicyRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.PolicyRepresentation) *gocloak.PolicyRepresentation); ok {
		r0 = rf(token, realm, clientID, policy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PolicyRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, gocloak.PolicyRepresentation) error); ok {
		r1 = rf(token, realm, clientID, policy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRealm provides a mock function with given fields: token, realm
func (_m *MockGoCloak) CreateRealm(token string, realm gocloak.RealmRepresentation) (string, error) {
	ret := _m.Called(token, realm)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, gocloak.RealmRepresentation) string); ok {
		r0 = rf(token, realm)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, gocloak.RealmRepresentation) error); ok {
		r1 = rf(token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRealmRole provides a mock function with given fields: token, realm, role
func (_m *MockGoCloak) CreateRealmRole(token string, realm string, role gocloak.Role) (string, error) {
	ret := _m.Called(token, realm, role)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, gocloak.Role) string); ok {
		r0 = rf(token, realm, role)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, gocloak.Role) error); ok {
		r1 = rf(token, realm, role)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateResource provides a mock function with given fields: token, realm, clientID, resource
func (_m *MockGoCloak) CreateResource(token string, realm string, clientID string, resource gocloak.ResourceRepresentation) (*gocloak.ResourceRepresentation, error) {
	ret := _m.Called(token, realm, clientID, resource)

	var r0 *gocloak.ResourceRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.ResourceRepresentation) *gocloak.ResourceRepresentation); ok {
		r0 = rf(token, realm, clientID, resource)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ResourceRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, gocloak.ResourceRepresentation) error); ok {
		r1 = rf(token, realm, clientID, resource)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateScope provides a mock function with given fields: token, realm, clientID, scope
func (_m *MockGoCloak) CreateScope(token string, realm string, clientID string, scope gocloak.ScopeRepresentation) (*gocloak.ScopeRepresentation, error) {
	ret := _m.Called(token, realm, clientID, scope)

	var r0 *gocloak.ScopeRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.ScopeRepresentation) *gocloak.ScopeRepresentation); ok {
		r0 = rf(token, realm, clientID, scope)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ScopeRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, gocloak.ScopeRepresentation) error); ok {
		r1 = rf(token, realm, clientID, scope)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUser provides a mock function with given fields: token, realm, user
func (_m *MockGoCloak) CreateUser(token string, realm string, user gocloak.User) (string, error) {
	ret := _m.Called(token, realm, user)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, gocloak.User) string); ok {
		r0 = rf(token, realm, user)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, gocloak.User) error); ok {
		r1 = rf(token, realm, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUserFederatedIdentity provides a mock function with given fields: token, realm, userID, providerID, federatedIdentityRep
func (_m *MockGoCloak) CreateUserFederatedIdentity(token string, realm string, userID string, providerID string, federatedIdentityRep gocloak.FederatedIdentityRepresentation) error {
	ret := _m.Called(token, realm, userID, providerID, federatedIdentityRep)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, gocloak.FederatedIdentityRepresentation) error); ok {
		r0 = rf(token, realm, userID, providerID, federatedIdentityRep)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DecodeAccessToken provides a mock function with given fields: accessToken, realm
func (_m *MockGoCloak) DecodeAccessToken(accessToken string, realm string) (*jwt.Token, *jwt.MapClaims, error) {
	ret := _m.Called(accessToken, realm)

	var r0 *jwt.Token
	if rf, ok := ret.Get(0).(func(string, string) *jwt.Token); ok {
		r0 = rf(accessToken, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jwt.Token)
		}
	}

	var r1 *jwt.MapClaims
	if rf, ok := ret.Get(1).(func(string, string) *jwt.MapClaims); ok {
		r1 = rf(accessToken, realm)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*jwt.MapClaims)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, string) error); ok {
		r2 = rf(accessToken, realm)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DecodeAccessTokenCustomClaims provides a mock function with given fields: accessToken, realm, claims
func (_m *MockGoCloak) DecodeAccessTokenCustomClaims(accessToken string, realm string, claims jwt.Claims) (*jwt.Token, error) {
	ret := _m.Called(accessToken, realm, claims)

	var r0 *jwt.Token
	if rf, ok := ret.Get(0).(func(string, string, jwt.Claims) *jwt.Token); ok {
		r0 = rf(accessToken, realm, claims)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jwt.Token)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, jwt.Claims) error); ok {
		r1 = rf(accessToken, realm, claims)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClient provides a mock function with given fields: accessToken, realm, clientID
func (_m *MockGoCloak) DeleteClient(accessToken string, realm string, clientID string) error {
	ret := _m.Called(accessToken, realm, clientID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(accessToken, realm, clientID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientProtocolMapper provides a mock function with given fields: token, realm, clientID, mapperID
func (_m *MockGoCloak) DeleteClientProtocolMapper(token string, realm string, clientID string, mapperID string) error {
	ret := _m.Called(token, realm, clientID, mapperID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(token, realm, clientID, mapperID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientRole provides a mock function with given fields: accessToken, realm, clientID, roleName
func (_m *MockGoCloak) DeleteClientRole(accessToken string, realm string, clientID string, roleName string) error {
	ret := _m.Called(accessToken, realm, clientID, roleName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(accessToken, realm, clientID, roleName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientRoleComposite provides a mock function with given fields: token, realm, roleID, roles
func (_m *MockGoCloak) DeleteClientRoleComposite(token string, realm string, roleID string, roles []gocloak.Role) error {
	ret := _m.Called(token, realm, roleID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, []gocloak.Role) error); ok {
		r0 = rf(token, realm, roleID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientRoleFromGroup provides a mock function with given fields: token, realm, clientID, groupID, roles
func (_m *MockGoCloak) DeleteClientRoleFromGroup(token string, realm string, clientID string, groupID string, roles []gocloak.Role) error {
	ret := _m.Called(token, realm, clientID, groupID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(token, realm, clientID, groupID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientRoleFromUser provides a mock function with given fields: token, realm, clientID, userID, roles
func (_m *MockGoCloak) DeleteClientRoleFromUser(token string, realm string, clientID string, userID string, roles []gocloak.Role) error {
	ret := _m.Called(token, realm, clientID, userID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, []gocloak.Role) error); ok {
		r0 = rf(token, realm, clientID, userID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteClientScope provides a mock function with given fields: accessToken, realm, scopeID
func (_m *MockGoCloak) DeleteClientScope(accessToken string, realm string, scopeID string) error {
	ret := _m.Called(accessToken, realm, scopeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(accessToken, realm, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteComponent provides a mock function with given fields: accessToken, realm, componentID
func (_m *MockGoCloak) DeleteComponent(accessToken string, realm string, componentID string) error {
	ret := _m.Called(accessToken, realm, componentID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(accessToken, realm, componentID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteGroup provides a mock function with given fields: accessToken, realm, groupID
func (_m *MockGoCloak) DeleteGroup(accessToken string, realm string, groupID string) error {
	ret := _m.Called(accessToken, realm, groupID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(accessToken, realm, groupID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteIdentityProvider provides a mock function with given fields: token, realm, alias
func (_m *MockGoCloak) DeleteIdentityProvider(token string, realm string, alias string) error {
	ret := _m.Called(token, realm, alias)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(token, realm, alias)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePermission provides a mock function with given fields: token, realm, clientID, permissionID
func (_m *MockGoCloak) DeletePermission(token string, realm string, clientID string, permissionID string) error {
	ret := _m.Called(token, realm, clientID, permissionID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(token, realm, clientID, permissionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePolicy provides a mock function with given fields: token, realm, clientID, policyID
func (_m *MockGoCloak) DeletePolicy(token string, realm string, clientID string, policyID string) error {
	ret := _m.Called(token, realm, clientID, policyID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(token, realm, clientID, policyID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteRealm provides a mock function with given fields: token, realm
func (_m *MockGoCloak) DeleteRealm(token string, realm string) error {
	ret := _m.Called(token, realm)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(token, realm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteRealmRole provides a mock function with given fields: token, realm, roleName
func (_m *MockGoCloak) DeleteRealmRole(token string, realm string, roleName string) error {
	ret := _m.Called(token, realm, roleName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(token, realm, roleName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteRealmRoleComposite provides a mock function with given fields: token, realm, roleName, roles
func (_m *MockGoCloak) DeleteRealmRoleComposite(token string, realm string, roleName string, roles []gocloak.Role) error {
	ret := _m.Called(token, realm, roleName, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, []gocloak.Role) error); ok {
		r0 = rf(token, realm, roleName, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteRealmRoleFromGroup provides a mock function with given fields: token, realm, groupID, roles
func (_m *MockGoCloak) DeleteRealmRoleFromGroup(token string, realm string, groupID string, roles []gocloak.Role) error {
	ret := _m.Called(token, realm, groupID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, []gocloak.Role) error); ok {
		r0 = rf(token, realm, groupID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteRealmRoleFromUser provides a mock function with given fields: token, realm, userID, roles
func (_m *MockGoCloak) DeleteRealmRoleFromUser(token string, realm string, userID string, roles []gocloak.Role) error {
	ret := _m.Called(token, realm, userID, roles)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, []gocloak.Role) error); ok {
		r0 = rf(token, realm, userID, roles)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteResource provides a mock function with given fields: token, realm, clientID, resourceID
func (_m *MockGoCloak) DeleteResource(token string, realm string, clientID string, resourceID string) error {
	ret := _m.Called(token, realm, clientID, resourceID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(token, realm, clientID, resourceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteScope provides a mock function with given fields: token, realm, clientID, scopeID
func (_m *MockGoCloak) DeleteScope(token string, realm string, clientID string, scopeID string) error {
	ret := _m.Called(token, realm, clientID, scopeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(token, realm, clientID, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUser provides a mock function with given fields: accessToken, realm, userID
func (_m *MockGoCloak) DeleteUser(accessToken string, realm string, userID string) error {
	ret := _m.Called(accessToken, realm, userID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(accessToken, realm, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUserFederatedIdentity provides a mock function with given fields: token, realm, userID, providerID
func (_m *MockGoCloak) DeleteUserFederatedIdentity(token string, realm string, userID string, providerID string) error {
	ret := _m.Called(token, realm, userID, providerID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(token, realm, userID, providerID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteUserFromGroup provides a mock function with given fields: token, realm, userID, groupID
func (_m *MockGoCloak) DeleteUserFromGroup(token string, realm string, userID string, groupID string) error {
	ret := _m.Called(token, realm, userID, groupID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(token, realm, userID, groupID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ExecuteActionsEmail provides a mock function with given fields: token, realm, params
func (_m *MockGoCloak) ExecuteActionsEmail(token string, realm string, params gocloak.ExecuteActionsEmail) error {
	ret := _m.Called(token, realm, params)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, gocloak.ExecuteActionsEmail) error); ok {
		r0 = rf(token, realm, params)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetCerts provides a mock function with given fields: realm
func (_m *MockGoCloak) GetCerts(realm string) (*gocloak.CertResponse, error) {
	ret := _m.Called(realm)

	var r0 *gocloak.CertResponse
	if rf, ok := ret.Get(0).(func(string) *gocloak.CertResponse); ok {
		r0 = rf(realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.CertResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClient provides a mock function with given fields: accessToken, realm, clientID
func (_m *MockGoCloak) GetClient(accessToken string, realm string, clientID string) (*gocloak.Client, error) {
	ret := _m.Called(accessToken, realm, clientID)

	var r0 *gocloak.Client
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.Client); ok {
		r0 = rf(accessToken, realm, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Client)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(accessToken, realm, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientOfflineSessions provides a mock function with given fields: token, realm, clientID
func (_m *MockGoCloak) GetClientOfflineSessions(token string, realm string, clientID string) ([]*gocloak.UserSessionRepresentation, error) {
	ret := _m.Called(token, realm, clientID)

	var r0 []*gocloak.UserSessionRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string) []*gocloak.UserSessionRepresentation); ok {
		r0 = rf(token, realm, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.UserSessionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientRole provides a mock function with given fields: token, realm, clientID, roleName
func (_m *MockGoCloak) GetClientRole(token string, realm string, clientID string, roleName string) (*gocloak.Role, error) {
	ret := _m.Called(token, realm, clientID, roleName)

	var r0 *gocloak.Role
	if rf, ok := ret.Get(0).(func(string, string, string, string) *gocloak.Role); ok {
		r0 = rf(token, realm, clientID, roleName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(token, realm, clientID, roleName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientRoles provides a mock function with given fields: accessToken, realm, clientID
func (_m *MockGoCloak) GetClientRoles(accessToken string, realm string, clientID string) ([]*gocloak.Role, error) {
	ret := _m.Called(accessToken, realm, clientID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(string, string, string) []*gocloak.Role); ok {
		r0 = rf(accessToken, realm, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(accessToken, realm, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientRolesByGroupID provides a mock function with given fields: token, realm, clientID, groupID
func (_m *MockGoCloak) GetClientRolesByGroupID(token string, realm string, clientID string, groupID string) ([]*gocloak.Role, error) {
	ret := _m.Called(token, realm, clientID, groupID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(token, realm, clientID, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(token, realm, clientID, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientRolesByUserID provides a mock function with given fields: token, realm, clientID, userID
func (_m *MockGoCloak) GetClientRolesByUserID(token string, realm string, clientID string, userID string) ([]*gocloak.Role, error) {
	ret := _m.Called(token, realm, clientID, userID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(token, realm, clientID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(token, realm, clientID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScope provides a mock function with given fields: token, realm, scopeID
func (_m *MockGoCloak) GetClientScope(token string, realm string, scopeID string) (*gocloak.ClientScope, error) {
	ret := _m.Called(token, realm, scopeID)

	var r0 *gocloak.ClientScope
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.ClientScope); ok {
		r0 = rf(token, realm, scopeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ClientScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, scopeID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientScopes provides a mock function with given fields: token, realm
func (_m *MockGoCloak) GetClientScopes(token string, realm string) ([]*gocloak.ClientScope, error) {
	ret := _m.Called(token, realm)

	var r0 []*gocloak.ClientScope
	if rf, ok := ret.Get(0).(func(string, string) []*gocloak.ClientScope); ok {
		r0 = rf(token, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ClientScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientSecret provides a mock function with given fields: token, realm, clientID
func (_m *MockGoCloak) GetClientSecret(token string, realm string, clientID string) (*gocloak.CredentialRepresentation, error) {
	ret := _m.Called(token, realm, clientID)

	var r0 *gocloak.CredentialRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.CredentialRepresentation); ok {
		r0 = rf(token, realm, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.CredentialRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientServiceAccount provides a mock function with given fields: token, realm, clientID
func (_m *MockGoCloak) GetClientServiceAccount(token string, realm string, clientID string) (*gocloak.User, error) {
	ret := _m.Called(token, realm, clientID)

	var r0 *gocloak.User
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.User); ok {
		r0 = rf(token, realm, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientUserSessions provides a mock function with given fields: token, realm, clientID
func (_m *MockGoCloak) GetClientUserSessions(token string, realm string, clientID string) ([]*gocloak.UserSessionRepresentation, error) {
	ret := _m.Called(token, realm, clientID)

	var r0 []*gocloak.UserSessionRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string) []*gocloak.UserSessionRepresentation); ok {
		r0 = rf(token, realm, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.UserSessionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClients provides a mock function with given fields: accessToken, realm, params
func (_m *MockGoCloak) GetClients(accessToken string, realm string, params gocloak.GetClientsParams) ([]*gocloak.Client, error) {
	ret := _m.Called(accessToken, realm, params)

	var r0 []*gocloak.Client
	if rf, ok := ret.Get(0).(func(string, string, gocloak.GetClientsParams) []*gocloak.Client); ok {
		r0 = rf(accessToken, realm, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Client)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, gocloak.GetClientsParams) error); ok {
		r1 = rf(accessToken, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientsDefaultScopes provides a mock function with given fields: token, realm, clientID
func (_m *MockGoCloak) GetClientsDefaultScopes(token string, realm string, clientID string) ([]*gocloak.ClientScope, error) {
	ret := _m.Called(token, realm, clientID)

	var r0 []*gocloak.ClientScope
	if rf, ok := ret.Get(0).(func(string, string, string) []*gocloak.ClientScope); ok {
		r0 = rf(token, realm, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ClientScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClientsOptionalScopes provides a mock function with given fields: token, realm, clientID
func (_m *MockGoCloak) GetClientsOptionalScopes(token string, realm string, clientID string) ([]*gocloak.ClientScope, error) {
	ret := _m.Called(token, realm, clientID)

	var r0 []*gocloak.ClientScope
	if rf, ok := ret.Get(0).(func(string, string, string) []*gocloak.ClientScope); ok {
		r0 = rf(token, realm, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ClientScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetComponents provides a mock function with given fields: accessToken, realm
func (_m *MockGoCloak) GetComponents(accessToken string, realm string) ([]*gocloak.Component, error) {
	ret := _m.Called(accessToken, realm)

	var r0 []*gocloak.Component
	if rf, ok := ret.Get(0).(func(string, string) []*gocloak.Component); ok {
		r0 = rf(accessToken, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Component)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(accessToken, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompositeClientRolesByGroupID provides a mock function with given fields: token, realm, clientID, groupID
func (_m *MockGoCloak) GetCompositeClientRolesByGroupID(token string, realm string, clientID string, groupID string) ([]*gocloak.Role, error) {
	ret := _m.Called(token, realm, clientID, groupID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(token, realm, clientID, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(token, realm, clientID, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompositeClientRolesByRoleID provides a mock function with given fields: token, realm, clientID, roleID
func (_m *MockGoCloak) GetCompositeClientRolesByRoleID(token string, realm string, clientID string, roleID string) ([]*gocloak.Role, error) {
	ret := _m.Called(token, realm, clientID, roleID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(token, realm, clientID, roleID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(token, realm, clientID, roleID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCompositeClientRolesByUserID provides a mock function with given fields: token, realm, clientID, userID
func (_m *MockGoCloak) GetCompositeClientRolesByUserID(token string, realm string, clientID string, userID string) ([]*gocloak.Role, error) {
	ret := _m.Called(token, realm, clientID, userID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(string, string, string, string) []*gocloak.Role); ok {
		r0 = rf(token, realm, clientID, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(token, realm, clientID, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultDefaultClientScopes provides a mock function with given fields: token, realm
func (_m *MockGoCloak) GetDefaultDefaultClientScopes(token string, realm string) ([]*gocloak.ClientScope, error) {
	ret := _m.Called(token, realm)

	var r0 []*gocloak.ClientScope
	if rf, ok := ret.Get(0).(func(string, string) []*gocloak.ClientScope); ok {
		r0 = rf(token, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ClientScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultGroups provides a mock function with given fields: accessToken, realm
func (_m *MockGoCloak) GetDefaultGroups(accessToken string, realm string) ([]*gocloak.Group, error) {
	ret := _m.Called(accessToken, realm)

	var r0 []*gocloak.Group
	if rf, ok := ret.Get(0).(func(string, string) []*gocloak.Group); ok {
		r0 = rf(accessToken, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Group)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(accessToken, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDefaultOptionalClientScopes provides a mock function with given fields: token, realm
func (_m *MockGoCloak) GetDefaultOptionalClientScopes(token string, realm string) ([]*gocloak.ClientScope, error) {
	ret := _m.Called(token, realm)

	var r0 []*gocloak.ClientScope
	if rf, ok := ret.Get(0).(func(string, string) []*gocloak.ClientScope); ok {
		r0 = rf(token, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ClientScope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroup provides a mock function with given fields: accessToken, realm, groupID
func (_m *MockGoCloak) GetGroup(accessToken string, realm string, groupID string) (*gocloak.Group, error) {
	ret := _m.Called(accessToken, realm, groupID)

	var r0 *gocloak.Group
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.Group); ok {
		r0 = rf(accessToken, realm, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Group)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(accessToken, realm, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroupMembers provides a mock function with given fields: accessToken, realm, groupID, params
func (_m *MockGoCloak) GetGroupMembers(accessToken string, realm string, groupID string, params gocloak.GetGroupsParams) ([]*gocloak.User, error) {
	ret := _m.Called(accessToken, realm, groupID, params)

	var r0 []*gocloak.User
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.GetGroupsParams) []*gocloak.User); ok {
		r0 = rf(accessToken, realm, groupID, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, gocloak.GetGroupsParams) error); ok {
		r1 = rf(accessToken, realm, groupID, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroups provides a mock function with given fields: accessToken, realm, params
func (_m *MockGoCloak) GetGroups(accessToken string, realm string, params gocloak.GetGroupsParams) ([]*gocloak.Group, error) {
	ret := _m.Called(accessToken, realm, params)

	var r0 []*gocloak.Group
	if rf, ok := ret.Get(0).(func(string, string, gocloak.GetGroupsParams) []*gocloak.Group); ok {
		r0 = rf(accessToken, realm, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Group)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, gocloak.GetGroupsParams) error); ok {
		r1 = rf(accessToken, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroupsCount provides a mock function with given fields: token, realm
func (_m *MockGoCloak) GetGroupsCount(token string, realm string) (int, error) {
	ret := _m.Called(token, realm)

	var r0 int
	if rf, ok := ret.Get(0).(func(string, string) int); ok {
		r0 = rf(token, realm)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityProvider provides a mock function with given fields: token, realm, alias
func (_m *MockGoCloak) GetIdentityProvider(token string, realm string, alias string) (*gocloak.IdentityProviderRepresentation, error) {
	ret := _m.Called(token, realm, alias)

	var r0 *gocloak.IdentityProviderRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.IdentityProviderRepresentation); ok {
		r0 = rf(token, realm, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.IdentityProviderRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, alias)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityProviders provides a mock function with given fields: token, realm
func (_m *MockGoCloak) GetIdentityProviders(token string, realm string) ([]*gocloak.IdentityProviderRepresentation, error) {
	ret := _m.Called(token, realm)

	var r0 []*gocloak.IdentityProviderRepresentation
	if rf, ok := ret.Get(0).(func(string, string) []*gocloak.IdentityProviderRepresentation); ok {
		r0 = rf(token, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.IdentityProviderRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIssuer provides a mock function with given fields: realm
func (_m *MockGoCloak) GetIssuer(realm string) (*gocloak.IssuerResponse, error) {
	ret := _m.Called(realm)

	var r0 *gocloak.IssuerResponse
	if rf, ok := ret.Get(0).(func(string) *gocloak.IssuerResponse); ok {
		r0 = rf(realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.IssuerResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKeyStoreConfig provides a mock function with given fields: accessToken, realm
func (_m *MockGoCloak) GetKeyStoreConfig(accessToken string, realm string) (*gocloak.KeyStoreConfig, error) {
	ret := _m.Called(accessToken, realm)

	var r0 *gocloak.KeyStoreConfig
	if rf, ok := ret.Get(0).(func(string, string) *gocloak.KeyStoreConfig); ok {
		r0 = rf(accessToken, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.KeyStoreConfig)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(accessToken, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPermission provides a mock function with given fields: token, realm, clientID, permissionID
func (_m *MockGoCloak) GetPermission(token string, realm string, clientID string, permissionID string) (*gocloak.PermissionRepresentation, error) {
	ret := _m.Called(token, realm, clientID, permissionID)

	var r0 *gocloak.PermissionRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, string) *gocloak.PermissionRepresentation); ok {
		r0 = rf(token, realm, clientID, permissionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PermissionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(token, realm, clientID, permissionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPermissions provides a mock function with given fields: token, realm, clientID, params
func (_m *MockGoCloak) GetPermissions(token string, realm string, clientID string, params gocloak.GetPermissionParams) ([]*gocloak.PermissionRepresentation, error) {
	ret := _m.Called(token, realm, clientID, params)

	var r0 []*gocloak.PermissionRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.GetPermissionParams) []*gocloak.PermissionRepresentation); ok {
		r0 = rf(token, realm, clientID, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.PermissionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, gocloak.GetPermissionParams) error); ok {
		r1 = rf(token, realm, clientID, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPolicies provides a mock function with given fields: token, realm, clientID, params
func (_m *MockGoCloak) GetPolicies(token string, realm string, clientID string, params gocloak.GetPolicyParams) ([]*gocloak.PolicyRepresentation, error) {
	ret := _m.Called(token, realm, clientID, params)

	var r0 []*gocloak.PolicyRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.GetPolicyParams) []*gocloak.PolicyRepresentation); ok {
		r0 = rf(token, realm, clientID, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.PolicyRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, gocloak.GetPolicyParams) error); ok {
		r1 = rf(token, realm, clientID, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPolicy provides a mock function with given fields: token, realm, clientID, policyID
func (_m *MockGoCloak) GetPolicy(token string, realm string, clientID string, policyID string) (*gocloak.PolicyRepresentation, error) {
	ret := _m.Called(token, realm, clientID, policyID)

	var r0 *gocloak.PolicyRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, string) *gocloak.PolicyRepresentation); ok {
		r0 = rf(token, realm, clientID, policyID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.PolicyRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(token, realm, clientID, policyID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealm provides a mock function with given fields: token, realm
func (_m *MockGoCloak) GetRealm(token string, realm string) (*gocloak.RealmRepresentation, error) {
	ret := _m.Called(token, realm)

	var r0 *gocloak.RealmRepresentation
	if rf, ok := ret.Get(0).(func(string, string) *gocloak.RealmRepresentation); ok {
		r0 = rf(token, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.RealmRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(token, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealmRole provides a mock function with given fields: token, realm, roleName
func (_m *MockGoCloak) GetRealmRole(token string, realm string, roleName string) (*gocloak.Role, error) {
	ret := _m.Called(token, realm, roleName)

	var r0 *gocloak.Role
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.Role); ok {
		r0 = rf(token, realm, roleName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, roleName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealmRoles provides a mock function with given fields: accessToken, realm
func (_m *MockGoCloak) GetRealmRoles(accessToken string, realm string) ([]*gocloak.Role, error) {
	ret := _m.Called(accessToken, realm)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(string, string) []*gocloak.Role); ok {
		r0 = rf(accessToken, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(accessToken, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealmRolesByGroupID provides a mock function with given fields: accessToken, realm, groupID
func (_m *MockGoCloak) GetRealmRolesByGroupID(accessToken string, realm string, groupID string) ([]*gocloak.Role, error) {
	ret := _m.Called(accessToken, realm, groupID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(string, string, string) []*gocloak.Role); ok {
		r0 = rf(accessToken, realm, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(accessToken, realm, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealmRolesByUserID provides a mock function with given fields: accessToken, realm, userID
func (_m *MockGoCloak) GetRealmRolesByUserID(accessToken string, realm string, userID string) ([]*gocloak.Role, error) {
	ret := _m.Called(accessToken, realm, userID)

	var r0 []*gocloak.Role
	if rf, ok := ret.Get(0).(func(string, string, string) []*gocloak.Role); ok {
		r0 = rf(accessToken, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(accessToken, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRealms provides a mock function with given fields: token
func (_m *MockGoCloak) GetRealms(token string) ([]*gocloak.RealmRepresentation, error) {
	ret := _m.Called(token)

	var r0 []*gocloak.RealmRepresentation
	if rf, ok := ret.Get(0).(func(string) []*gocloak.RealmRepresentation); ok {
		r0 = rf(token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.RealmRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRequestingPartyToken provides a mock function with given fields: token, realm, options
func (_m *MockGoCloak) GetRequestingPartyToken(token string, realm string, options gocloak.RequestingPartyTokenOptions) (*gocloak.JWT, error) {
	ret := _m.Called(token, realm, options)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(string, string, gocloak.RequestingPartyTokenOptions) *gocloak.JWT); ok {
		r0 = rf(token, realm, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, gocloak.RequestingPartyTokenOptions) error); ok {
		r1 = rf(token, realm, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResource provides a mock function with given fields: token, realm, clientID, resourceID
func (_m *MockGoCloak) GetResource(token string, realm string, clientID string, resourceID string) (*gocloak.ResourceRepresentation, error) {
	ret := _m.Called(token, realm, clientID, resourceID)

	var r0 *gocloak.ResourceRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, string) *gocloak.ResourceRepresentation); ok {
		r0 = rf(token, realm, clientID, resourceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ResourceRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(token, realm, clientID, resourceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetResources provides a mock function with given fields: token, realm, clientID, params
func (_m *MockGoCloak) GetResources(token string, realm string, clientID string, params gocloak.GetResourceParams) ([]*gocloak.ResourceRepresentation, error) {
	ret := _m.Called(token, realm, clientID, params)

	var r0 []*gocloak.ResourceRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.GetResourceParams) []*gocloak.ResourceRepresentation); ok {
		r0 = rf(token, realm, clientID, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ResourceRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, gocloak.GetResourceParams) error); ok {
		r1 = rf(token, realm, clientID, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRoleMappingByGroupID provides a mock function with given fields: accessToken, realm, groupID
func (_m *MockGoCloak) GetRoleMappingByGroupID(accessToken string, realm string, groupID string) (*gocloak.MappingsRepresentation, error) {
	ret := _m.Called(accessToken, realm, groupID)

	var r0 *gocloak.MappingsRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.MappingsRepresentation); ok {
		r0 = rf(accessToken, realm, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.MappingsRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(accessToken, realm, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRoleMappingByUserID provides a mock function with given fields: accessToken, realm, userID
func (_m *MockGoCloak) GetRoleMappingByUserID(accessToken string, realm string, userID string) (*gocloak.MappingsRepresentation, error) {
	ret := _m.Called(accessToken, realm, userID)

	var r0 *gocloak.MappingsRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.MappingsRepresentation); ok {
		r0 = rf(accessToken, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.MappingsRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(accessToken, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetScope provides a mock function with given fields: token, realm, clientID, scopeID
func (_m *MockGoCloak) GetScope(token string, realm string, clientID string, scopeID string) (*gocloak.ScopeRepresentation, error) {
	ret := _m.Called(token, realm, clientID, scopeID)

	var r0 *gocloak.ScopeRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, string) *gocloak.ScopeRepresentation); ok {
		r0 = rf(token, realm, clientID, scopeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ScopeRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(token, realm, clientID, scopeID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetScopes provides a mock function with given fields: token, realm, clientID, params
func (_m *MockGoCloak) GetScopes(token string, realm string, clientID string, params gocloak.GetScopeParams) ([]*gocloak.ScopeRepresentation, error) {
	ret := _m.Called(token, realm, clientID, params)

	var r0 []*gocloak.ScopeRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.GetScopeParams) []*gocloak.ScopeRepresentation); ok {
		r0 = rf(token, realm, clientID, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.ScopeRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, gocloak.GetScopeParams) error); ok {
		r1 = rf(token, realm, clientID, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetServerInfo provides a mock function with given fields: accessToken
func (_m *MockGoCloak) GetServerInfo(accessToken string) (*gocloak.ServerInfoRepesentation, error) {
	ret := _m.Called(accessToken)

	var r0 *gocloak.ServerInfoRepesentation
	if rf, ok := ret.Get(0).(func(string) *gocloak.ServerInfoRepesentation); ok {
		r0 = rf(accessToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.ServerInfoRepesentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(accessToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetToken provides a mock function with given fields: realm, options
func (_m *MockGoCloak) GetToken(realm string, options gocloak.TokenOptions) (*gocloak.JWT, error) {
	ret := _m.Called(realm, options)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(string, gocloak.TokenOptions) *gocloak.JWT); ok {
		r0 = rf(realm, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, gocloak.TokenOptions) error); ok {
		r1 = rf(realm, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserByID provides a mock function with given fields: accessToken, realm, userID
func (_m *MockGoCloak) GetUserByID(accessToken string, realm string, userID string) (*gocloak.User, error) {
	ret := _m.Called(accessToken, realm, userID)

	var r0 *gocloak.User
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.User); ok {
		r0 = rf(accessToken, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(accessToken, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserCount provides a mock function with given fields: accessToken, realm
func (_m *MockGoCloak) GetUserCount(accessToken string, realm string) (int, error) {
	ret := _m.Called(accessToken, realm)

	var r0 int
	if rf, ok := ret.Get(0).(func(string, string) int); ok {
		r0 = rf(accessToken, realm)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(accessToken, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserFederatedIdentities provides a mock function with given fields: token, realm, userID
func (_m *MockGoCloak) GetUserFederatedIdentities(token string, realm string, userID string) ([]*gocloak.FederatedIdentityRepresentation, error) {
	ret := _m.Called(token, realm, userID)

	var r0 []*gocloak.FederatedIdentityRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string) []*gocloak.FederatedIdentityRepresentation); ok {
		r0 = rf(token, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.FederatedIdentityRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserGroups provides a mock function with given fields: accessToken, realm, userID
func (_m *MockGoCloak) GetUserGroups(accessToken string, realm string, userID string) ([]*gocloak.UserGroup, error) {
	ret := _m.Called(accessToken, realm, userID)

	var r0 []*gocloak.UserGroup
	if rf, ok := ret.Get(0).(func(string, string, string) []*gocloak.UserGroup); ok {
		r0 = rf(accessToken, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.UserGroup)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(accessToken, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserInfo provides a mock function with given fields: accessToken, realm
func (_m *MockGoCloak) GetUserInfo(accessToken string, realm string) (*gocloak.UserInfo, error) {
	ret := _m.Called(accessToken, realm)

	var r0 *gocloak.UserInfo
	if rf, ok := ret.Get(0).(func(string, string) *gocloak.UserInfo); ok {
		r0 = rf(accessToken, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.UserInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(accessToken, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserOfflineSessionsForClient provides a mock function with given fields: token, realm, userID, clientID
func (_m *MockGoCloak) GetUserOfflineSessionsForClient(token string, realm string, userID string, clientID string) ([]*gocloak.UserSessionRepresentation, error) {
	ret := _m.Called(token, realm, userID, clientID)

	var r0 []*gocloak.UserSessionRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string, string) []*gocloak.UserSessionRepresentation); ok {
		r0 = rf(token, realm, userID, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.UserSessionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(token, realm, userID, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserSessions provides a mock function with given fields: token, realm, userID
func (_m *MockGoCloak) GetUserSessions(token string, realm string, userID string) ([]*gocloak.UserSessionRepresentation, error) {
	ret := _m.Called(token, realm, userID)

	var r0 []*gocloak.UserSessionRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string) []*gocloak.UserSessionRepresentation); ok {
		r0 = rf(token, realm, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.UserSessionRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUsers provides a mock function with given fields: accessToken, realm, params
func (_m *MockGoCloak) GetUsers(accessToken string, realm string, params gocloak.GetUsersParams) ([]*gocloak.User, error) {
	ret := _m.Called(accessToken, realm, params)

	var r0 []*gocloak.User
	if rf, ok := ret.Get(0).(func(string, string, gocloak.GetUsersParams) []*gocloak.User); ok {
		r0 = rf(accessToken, realm, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, gocloak.GetUsersParams) error); ok {
		r1 = rf(accessToken, realm, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUsersByClientRoleName provides a mock function with given fields: token, realm, clientID, roleName, params
func (_m *MockGoCloak) GetUsersByClientRoleName(token string, realm string, clientID string, roleName string, params gocloak.GetUsersByRoleParams) ([]*gocloak.User, error) {
	ret := _m.Called(token, realm, clientID, roleName, params)

	var r0 []*gocloak.User
	if rf, ok := ret.Get(0).(func(string, string, string, string, gocloak.GetUsersByRoleParams) []*gocloak.User); ok {
		r0 = rf(token, realm, clientID, roleName, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, gocloak.GetUsersByRoleParams) error); ok {
		r1 = rf(token, realm, clientID, roleName, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUsersByRoleName provides a mock function with given fields: token, realm, roleName
func (_m *MockGoCloak) GetUsersByRoleName(token string, realm string, roleName string) ([]*gocloak.User, error) {
	ret := _m.Called(token, realm, roleName)

	var r0 []*gocloak.User
	if rf, ok := ret.Get(0).(func(string, string, string) []*gocloak.User); ok {
		r0 = rf(token, realm, roleName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gocloak.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, roleName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Login provides a mock function with given fields: clientID, clientSecret, realm, username, password
func (_m *MockGoCloak) Login(clientID string, clientSecret string, realm string, username string, password string) (*gocloak.JWT, error) {
	ret := _m.Called(clientID, clientSecret, realm, username, password)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(string, string, string, string, string) *gocloak.JWT); ok {
		r0 = rf(clientID, clientSecret, realm, username, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, string) error); ok {
		r1 = rf(clientID, clientSecret, realm, username, password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoginAdmin provides a mock function with given fields: username, password, realm
func (_m *MockGoCloak) LoginAdmin(username string, password string, realm string) (*gocloak.JWT, error) {
	ret := _m.Called(username, password, realm)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.JWT); ok {
		r0 = rf(username, password, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(username, password, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoginClient provides a mock function with given fields: clientID, clientSecret, realm
func (_m *MockGoCloak) LoginClient(clientID string, clientSecret string, realm string) (*gocloak.JWT, error) {
	ret := _m.Called(clientID, clientSecret, realm)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.JWT); ok {
		r0 = rf(clientID, clientSecret, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(clientID, clientSecret, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Logout provides a mock function with given fields: clientID, clientSecret, realm, refreshToken
func (_m *MockGoCloak) Logout(clientID string, clientSecret string, realm string, refreshToken string) error {
	ret := _m.Called(clientID, clientSecret, realm, refreshToken)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(clientID, clientSecret, realm, refreshToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LogoutPublicClient provides a mock function with given fields: clientID, realm, accessToken, refreshToken
func (_m *MockGoCloak) LogoutPublicClient(clientID string, realm string, accessToken string, refreshToken string) error {
	ret := _m.Called(clientID, realm, accessToken, refreshToken)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(clientID, realm, accessToken, refreshToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RefreshToken provides a mock function with given fields: refreshToken, clientID, clientSecret, realm
func (_m *MockGoCloak) RefreshToken(refreshToken string, clientID string, clientSecret string, realm string) (*gocloak.JWT, error) {
	ret := _m.Called(refreshToken, clientID, clientSecret, realm)

	var r0 *gocloak.JWT
	if rf, ok := ret.Get(0).(func(string, string, string, string) *gocloak.JWT); ok {
		r0 = rf(refreshToken, clientID, clientSecret, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.JWT)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(refreshToken, clientID, clientSecret, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegenerateClientSecret provides a mock function with given fields: token, realm, clientID
func (_m *MockGoCloak) RegenerateClientSecret(token string, realm string, clientID string) (*gocloak.CredentialRepresentation, error) {
	ret := _m.Called(token, realm, clientID)

	var r0 *gocloak.CredentialRepresentation
	if rf, ok := ret.Get(0).(func(string, string, string) *gocloak.CredentialRepresentation); ok {
		r0 = rf(token, realm, clientID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.CredentialRepresentation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(token, realm, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveDefaultGroup provides a mock function with given fields: accessToken, realm, groupID
func (_m *MockGoCloak) RemoveDefaultGroup(accessToken string, realm string, groupID string) error {
	ret := _m.Called(accessToken, realm, groupID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(accessToken, realm, groupID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveDefaultScopeFromClient provides a mock function with given fields: token, realm, clientID, scopeID
func (_m *MockGoCloak) RemoveDefaultScopeFromClient(token string, realm string, clientID string, scopeID string) error {
	ret := _m.Called(token, realm, clientID, scopeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(token, realm, clientID, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveOptionalScopeFromClient provides a mock function with given fields: token, realm, clientID, scopeID
func (_m *MockGoCloak) RemoveOptionalScopeFromClient(token string, realm string, clientID string, scopeID string) error {
	ret := _m.Called(token, realm, clientID, scopeID)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string) error); ok {
		r0 = rf(token, realm, clientID, scopeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RestyClient provides a mock function with given fields:
func (_m *MockGoCloak) RestyClient() *resty.Client {
	ret := _m.Called()

	var r0 *resty.Client
	if rf, ok := ret.Get(0).(func() *resty.Client); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*resty.Client)
		}
	}

	return r0
}

// RetrospectToken provides a mock function with given fields: accessToken, clientID, clientSecret, realm
func (_m *MockGoCloak) RetrospectToken(accessToken string, clientID string, clientSecret string, realm string) (*gocloak.RetrospecTokenResult, error) {
	ret := _m.Called(accessToken, clientID, clientSecret, realm)

	var r0 *gocloak.RetrospecTokenResult
	if rf, ok := ret.Get(0).(func(string, string, string, string) *gocloak.RetrospecTokenResult); ok {
		r0 = rf(accessToken, clientID, clientSecret, realm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gocloak.RetrospecTokenResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(accessToken, clientID, clientSecret, realm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetPassword provides a mock function with given fields: token, userID, realm, password, temporary
func (_m *MockGoCloak) SetPassword(token string, userID string, realm string, password string, temporary bool) error {
	ret := _m.Called(token, userID, realm, password, temporary)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, bool) error); ok {
		r0 = rf(token, userID, realm, password, temporary)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetRestyClient provides a mock function with given fields: restyClient
func (_m *MockGoCloak) SetRestyClient(restyClient *resty.Client) {
	_m.Called(restyClient)
}

// UpdateClient provides a mock function with given fields: accessToken, realm, updatedClient
func (_m *MockGoCloak) UpdateClient(accessToken string, realm string, updatedClient gocloak.Client) error {
	ret := _m.Called(accessToken, realm, updatedClient)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, gocloak.Client) error); ok {
		r0 = rf(accessToken, realm, updatedClient)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateClientProtocolMapper provides a mock function with given fields: token, realm, clientID, mapperID, mapper
func (_m *MockGoCloak) UpdateClientProtocolMapper(token string, realm string, clientID string, mapperID string, mapper gocloak.ProtocolMapperRepresentation) error {
	ret := _m.Called(token, realm, clientID, mapperID, mapper)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, string, gocloak.ProtocolMapperRepresentation) error); ok {
		r0 = rf(token, realm, clientID, mapperID, mapper)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateClientScope provides a mock function with given fields: accessToken, realm, scope
func (_m *MockGoCloak) UpdateClientScope(accessToken string, realm string, scope gocloak.ClientScope) error {
	ret := _m.Called(accessToken, realm, scope)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, gocloak.ClientScope) error); ok {
		r0 = rf(accessToken, realm, scope)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateGroup provides a mock function with given fields: accessToken, realm, updatedGroup
func (_m *MockGoCloak) UpdateGroup(accessToken string, realm string, updatedGroup gocloak.Group) error {
	ret := _m.Called(accessToken, realm, updatedGroup)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, gocloak.Group) error); ok {
		r0 = rf(accessToken, realm, updatedGroup)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateIdentityProvider provides a mock function with given fields: token, realm, alias, providerRep
func (_m *MockGoCloak) UpdateIdentityProvider(token string, realm string, alias string, providerRep gocloak.IdentityProviderRepresentation) error {
	ret := _m.Called(token, realm, alias, providerRep)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.IdentityProviderRepresentation) error); ok {
		r0 = rf(token, realm, alias, providerRep)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdatePermission provides a mock function with given fields: token, realm, clientID, permission
func (_m *MockGoCloak) UpdatePermission(token string, realm string, clientID string, permission gocloak.PermissionRepresentation) error {
	ret := _m.Called(token, realm, clientID, permission)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.PermissionRepresentation) error); ok {
		r0 = rf(token, realm, clientID, permission)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdatePolicy provides a mock function with given fields: token, realm, clientID, policy
func (_m *MockGoCloak) UpdatePolicy(token string, realm string, clientID string, policy gocloak.PolicyRepresentation) error {
	ret := _m.Called(token, realm, clientID, policy)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.PolicyRepresentation) error); ok {
		r0 = rf(token, realm, clientID, policy)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRealm provides a mock function with given fields: token, realm
func (_m *MockGoCloak) UpdateRealm(token string, realm gocloak.RealmRepresentation) error {
	ret := _m.Called(token, realm)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, gocloak.RealmRepresentation) error); ok {
		r0 = rf(token, realm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRealmRole provides a mock function with given fields: token, realm, roleName, role
func (_m *MockGoCloak) UpdateRealmRole(token string, realm string, roleName string, role gocloak.Role) error {
	ret := _m.Called(token, realm, roleName, role)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.Role) error); ok {
		r0 = rf(token, realm, roleName, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateResource provides a mock function with given fields: token, realm, clientID, resource
func (_m *MockGoCloak) UpdateResource(token string, realm string, clientID string, resource gocloak.ResourceRepresentation) error {
	ret := _m.Called(token, realm, clientID, resource)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.ResourceRepresentation) error); ok {
		r0 = rf(token, realm, clientID, resource)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRole provides a mock function with given fields: accessToken, realm, clientID, role
func (_m *MockGoCloak) UpdateRole(accessToken string, realm string, clientID string, role gocloak.Role) error {
	ret := _m.Called(accessToken, realm, clientID, role)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.Role) error); ok {
		r0 = rf(accessToken, realm, clientID, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateScope provides a mock function with given fields: token, realm, clientID, resource
func (_m *MockGoCloak) UpdateScope(token string, realm string, clientID string, resource gocloak.ScopeRepresentation) error {
	ret := _m.Called(token, realm, clientID, resource)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, gocloak.ScopeRepresentation) error); ok {
		r0 = rf(token, realm, clientID, resource)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateUser provides a mock function with given fields: accessToken, realm, user
func (_m *MockGoCloak) UpdateUser(accessToken string, realm string, user gocloak.User) error {
	ret := _m.Called(accessToken, realm, user)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, gocloak.User) error); ok {
		r0 = rf(accessToken, realm, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UserAttributeContains provides a mock function with given fields: attributes, attribute, value
func (_m *MockGoCloak) UserAttributeContains(attributes map[string][]string, attribute string, value string) bool {
	ret := _m.Called(attributes, attribute, value)

	var r0 bool
	if rf, ok := ret.Get(0).(func(map[string][]string, string, string) bool); ok {
		r0 = rf(attributes, attribute, value)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}
